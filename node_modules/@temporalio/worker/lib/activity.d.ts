/// <reference types="node" />
import 'abort-controller/polyfill';
import { Context, Info } from '@temporalio/activity';
import { ActivityFunction, LoadedDataConverter } from '@temporalio/common';
import { coresdk } from '@temporalio/proto';
import { ActivityExecuteInput, ActivityInboundCallsInterceptor, ActivityInterceptorsFactory, ActivityOutboundCallsInterceptor } from './interceptors';
import { Logger } from './logger';
export type CancelReason = keyof typeof coresdk.activity_task.ActivityCancelReason | 'WORKER_SHUTDOWN' | 'HEARTBEAT_DETAILS_CONVERSION_FAILED';
export declare class Activity {
    readonly info: Info;
    readonly fn: ActivityFunction<any[], any> | undefined;
    readonly dataConverter: LoadedDataConverter;
    readonly heartbeatCallback: Context['heartbeat'];
    protected cancelReason?: CancelReason;
    readonly context: Context;
    cancel: (reason: CancelReason) => void;
    readonly abortController: AbortController;
    readonly interceptors: {
        inbound: ActivityInboundCallsInterceptor[];
        outbound: ActivityOutboundCallsInterceptor[];
    };
    constructor(info: Info, fn: ActivityFunction<any[], any> | undefined, dataConverter: LoadedDataConverter, heartbeatCallback: Context['heartbeat'], interceptors: ActivityInterceptorsFactory[]);
    protected getLogAttributes(): Record<string, unknown>;
    protected makeActivityLogger(): Logger;
    /**
     * Actually executes the function.
     *
     * Any call up to this function and including this one will be trimmed out of stack traces.
     */
    protected execute(fn: ActivityFunction<any[], any>, input: ActivityExecuteInput): Promise<unknown>;
    run(input: ActivityExecuteInput): Promise<coresdk.activity_result.IActivityExecutionResult>;
    runNoEncoding(fn: ActivityFunction<any[], any>, input: ActivityExecuteInput): Promise<unknown>;
}
/**
 * Returns a map of attributes to be set on log messages for a given Activity
 */
export declare function activityLogAttributes(info: Info): Record<string, unknown>;
