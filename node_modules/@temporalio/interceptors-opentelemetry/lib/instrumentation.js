"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.instrument = exports.headersWithContext = exports.extractContextFromHeaders = exports.RUN_ID_ATTR_KEY = exports.TRACE_HEADER = void 0;
/**
 * opentelemetry instrumentation helper functions
 * @module
 */
const otel = __importStar(require("@opentelemetry/api"));
const common_1 = require("@temporalio/common");
/** Default trace header for opentelemetry interceptors */
exports.TRACE_HEADER = '_tracer-data';
/** As in workflow run id */
exports.RUN_ID_ATTR_KEY = 'run_id';
const payloadConverter = common_1.defaultPayloadConverter;
/**
 * If found, return an otel Context deserialized from the provided headers
 */
async function extractContextFromHeaders(headers) {
    const encodedSpanContext = headers[exports.TRACE_HEADER];
    if (encodedSpanContext === undefined) {
        return undefined;
    }
    const textMap = payloadConverter.fromPayload(encodedSpanContext);
    return otel.propagation.extract(otel.context.active(), textMap, otel.defaultTextMapGetter);
}
exports.extractContextFromHeaders = extractContextFromHeaders;
/**
 * Given headers, return new headers with the current otel context inserted
 */
async function headersWithContext(headers) {
    const carrier = {};
    otel.propagation.inject(otel.context.active(), carrier, otel.defaultTextMapSetter);
    return { ...headers, [exports.TRACE_HEADER]: payloadConverter.toPayload(carrier) };
}
exports.headersWithContext = headersWithContext;
async function wrapWithSpan(span, fn, acceptableErrors) {
    try {
        const ret = await fn(span);
        span.setStatus({ code: otel.SpanStatusCode.OK });
        return ret;
    }
    catch (err) {
        if (acceptableErrors === undefined || !acceptableErrors(err)) {
            span.setStatus({ code: otel.SpanStatusCode.ERROR });
            span.recordException(err);
        }
        else {
            span.setStatus({ code: otel.SpanStatusCode.OK });
        }
        throw err;
    }
    finally {
        span.end();
    }
}
/**
 * Wraps `fn` in a span which ends when function returns or throws
 */
async function instrument({ tracer, spanName, fn, context, acceptableErrors, }) {
    if (context) {
        return await otel.context.with(context, async () => {
            return await tracer.startActiveSpan(spanName, async (span) => await wrapWithSpan(span, fn, acceptableErrors));
        });
    }
    return await tracer.startActiveSpan(spanName, async (span) => await wrapWithSpan(span, fn, acceptableErrors));
}
exports.instrument = instrument;
//# sourceMappingURL=instrumentation.js.map